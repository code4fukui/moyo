import tinycolor from "https://bgrins.github.io/TinyColor/mod.js";

// Generated by CoffeeScript 2.7.0
  /**
   * Generates rhombic and kites and darts Penrose tilings.
   * @submodule Penrose
   */
  /**
   * Contains three vertices and other meta data for a single tile.
   * @class Tile
   * @constructor
   * @private
   * @param v0 {Number} vertex 0
   * @param v1 {Number} vertex 1
   * @param v2 {Number} vertex 2
   * @param type {String} Tile type (e.g. kite, dart, thin, fat rhomb...)
   * @param tile01 {Number} Array index of a tile adjacent to [v0, v1]. null is rim.
   * @param tile12 {Number} Array index of a tile adjacent to [v1, v2]. null is rim.
   * @param pair {Number} Array index of tiles which is the other half of this tile (adj to [v2, v3]. null is rim.
   */
  /**
   * Inflation logics for "fat" tile type.
   * @method inflateFat
   * @private
   * @param verts {Array} Array of all vertices.
   * @param tiles {Array} Array of all tiles.
   * @param index {Number} Index of this tile in tiles.
   */
  /**
   * Inflation logics for "thin" tile type.
   * @method inflateThin
   * @private
   * @param verts {Array} Array of all vertices.
   * @param tiles {Array} Array of all tiles.
   * @param index {Number} Index of this tile in tiles.
   */
  var PenroseKiteAndDart, PenroseRhombus, Tile, diff, getRandomColor, inflateDart, inflateFat, inflateKite, inflateThin, mult, r, random, sqrt, sum;

  // ================================
  // Modules
  //svg = SVG = require('svgjs');

  //tinycolor = require('tinycolor2');

  // ================================
  // Constants
  sqrt = Math.sqrt;

  random = Math.random;

  r = (1 + sqrt(5)) / 2;

  // ================================
  // Utilities

  // Get some hex string
  getRandomColor = function() {
    return tinycolor({
      h: parseInt(360 * random()),
      s: 0.6,
      l: 0.6
    }).toHexString();
  };

  // Va + Vb
  sum = function(va, vb) {
    return [va[0] + vb[0], va[1] + vb[1]];
  };

  // Va - Vb
  diff = function(va, vb) {
    return [va[0] - vb[0], va[1] - vb[1]];
  };

  // Vector * a
  mult = function(v, a) {
    return [a * v[0], a * v[1]];
  };

  inflateThin = function(verts, tiles, index) {
    var Tadj, Tnew, Vnew, c0, c01, c1, c12, c2, cpair;
    // Check if @tile received adjacent tile change. If not, propagate old info
    // and let other tiles handle the update
    if (this.t01.dirty) {
      c01 = this.t01.tile.slice();
      Tadj = c01[0];
      // Adjacent tile already created the new vertex, so use it
      Vnew = tiles[c01[1]].v0;
    } else {
      c01 = this.t01.tile;
      Tadj = c01;
      // Get the new vertex resulting from inflation
      // Vnew = v1 + (r - 1)(v0 - v1)
      Vnew = verts.push(sum(verts[this.v1], mult(diff(verts[this.v0], verts[this.v1]), r - 1))) - 1;
    }
    c12 = this.t12.tile;
    cpair = this.pair.tile;
    // Reorient @tile
    c0 = this.v0;
    c1 = this.v1;
    c2 = this.v2;
    this.v0 = Vnew;
    this.v1 = c2;
    this.v2 = c0;
    // Create new Tile and push to tiles
    Tnew = tiles.push(new Tile(c2, Vnew, c1, "fat", index, Tadj, c12)) - 1;
    // Propagate to adjacent tiles about my changes, then clean off my dirty flags
    this.t01.tile = Tnew;
    if (c01 != null) {
      if (this.t01.dirty) {
        tiles[c01[0]].t12.tile = Tnew;
        tiles[c01[1]].pair.tile = index;
        this.pair.tile = c01[1];
      } else {
        tiles[c01].t01 = {
          tile: [Tnew, index],
          dirty: true
        };
      }
    } else {
      this.pair.tile = null;
    }
    if (c12 != null) {
      if (this.t12.dirty) {
        tiles[c12].pair.tile = Tnew;
      } else {
        tiles[c12].t12 = {
          tile: Tnew,
          dirty: true
        };
      }
    }
    if (cpair != null) {
      if (this.pair.dirty) {
        tiles[cpair].t12.tile = index;
      } else {
        tiles[cpair].pair = {
          tile: index,
          dirty: true
        };
      }
    } else {
      this.t12.tile = null;
    }
    // Finally, reset my dirty flags
    this.t01.dirty = false;
    this.t12.dirty = false;
    return this.pair.dirty = false;
  };

  inflateFat = function(verts, tiles, index) {
    var Tfat, Tnewfat, Tnewthin, Tthin, V01, Vpair, c0, c01, c1, c12, c2, cpair;
    // Check if @tile received adjacent tile changes. If not, propagate old info
    // and let other tiles handle the update
    if (this.t01.dirty) {
      c01 = this.t01.tile.slice();
      Tthin = c01[1];
      // Adjacent tile already created the new vertex, so use it
      V01 = tiles[c01[1]].v0;
    } else {
      c01 = this.t01.tile;
      Tthin = c01;
      // Get the new vertex resulting from inflation
      // Vnew = v0 + (r - 1)(v1 - v0)
      V01 = verts.push(sum(verts[this.v0], mult(diff(verts[this.v1], verts[this.v0]), r - 1))) - 1;
    }
    c12 = this.t12.tile;
    if (this.pair.dirty) {
      cpair = this.pair.tile.slice();
      Tfat = cpair[1];
      // Adjacent tile already created the new vertex, so use it
      Vpair = tiles[cpair[0]].v0;
    } else {
      cpair = this.pair.tile;
      Tfat = cpair;
      // Get the new vertex resulting from inflation
      // Vnew = v0 + (r - 1)(v2 - v0)
      Vpair = verts.push(sum(verts[this.v0], mult(diff(verts[this.v2], verts[this.v0]), r - 1))) - 1;
    }
    // Reorient @tile
    c0 = this.v0;
    c1 = this.v1;
    c2 = this.v2;
    this.v0 = Vpair;
    this.v1 = V01;
    this.v2 = c0;
    // Create new Tiles and push to tiles
    Tnewthin = tiles.push(new Tile(V01, Vpair, c1, "thin", index, null, Tthin)) - 1;
    Tnewfat = tiles.push(new Tile(c2, Vpair, c1, "fat", Tfat, Tnewthin, c12)) - 1;
    tiles[Tnewthin].t12.tile = Tnewfat;
    // Propagate to adjacent tiles about my changes, update my knowledge of adjacent tiles,
    // then clean off my dirty flags
    this.t01.tile = Tnewthin;
    if (c01 != null) {
      if (this.t01.dirty) {
        this.t12.tile = c01[0];
        tiles[c01[0]].t12.tile = index;
        tiles[Tthin].pair.tile = Tnewthin;
      } else {
        tiles[c01].t01 = {
          tile: [index, Tnewthin],
          dirty: true
        };
      }
    } else {
      this.t12.tile = null;
    }
    if (c12 != null) {
      if (this.t12.dirty) {
        tiles[c12].pair.tile = Tnewfat;
      } else {
        tiles[c12].t12 = {
          tile: Tnewfat,
          dirty: true
        };
      }
    }
    if (cpair != null) {
      if (this.pair.dirty) {
        this.pair.tile = cpair[0];
        tiles[cpair[0]].pair.tile = index;
        tiles[Tfat].t01.tile = Tnewfat;
      } else {
        tiles[cpair].pair = {
          tile: [index, Tnewfat],
          dirty: true
        };
      }
    } else {
      this.pair.tile = null;
    }
    // Finally, reset my dirty flags
    this.t01.dirty = false;
    this.t12.dirty = false;
    return this.pair.dirty = false;
  };

  inflateKite = function() {};

  inflateDart = function() {};

  Tile = (function() {
    class Tile {
      constructor(v0, v1, v2, type, tile01, tile12, pair) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.type = this.types[type];
        // Adjacency info, where dirty is flag for tile change. This flag
        // is referenced and modified by adjacent tiles when they inflate
        this.t01 = {
          tile: tile01,
          dirty: false
        };
        this.t12 = {
          tile: tile12,
          dirty: false
        };
        this.pair = {
          tile: pair,
          dirty: false
        };
        // Inflation logics for this Tile
        switch (type) {
          case "thin":
            this.inflate = inflateThin;
            break;
          case "fat":
            this.inflate = inflateFat;
            break;
          case "kite":
            this.inflate = inflateKite;
            break;
          case "dart":
            this.inflate = inflateDart;
        }
      }

    };

    // Enumerate string tile names to save memory
    Tile.prototype.types = {
      thin: 0,
      fat: 1,
      kite: 2,
      dart: 3,
      0: 'thin',
      1: 'fat',
      2: 'kite',
      3: 'dart'
    };

    return Tile;

  }).call(this);

  /**
   * Implementation for Rhombus Penrose Tiling.
   * @class PenroseRhombus
   * @constructor
   * @private
   * @param [opts] {Object} Options to style the tile.
   * @param [opts.initTileType="fat"] {String} The starting tile for subsequent inflations. Can be "thin" or "fat".
   * @param [...attrs] {Array} Attributes for each tile type.
   */
  PenroseRhombus = class PenroseRhombus {
    constructor(opts, ...attrs) {
      var attr, base;
      // Scope
      this.opts = opts;
      // Assign defaults
      if ((base = this.opts).initTileType == null) {
        base.initTileType = "fat";
      }
      attr = {
        stroke: "#333",
        "stroke-width": 2,
        "stroke-linejoin": "round"
      };
      this.attrs = [];
      this.attrs[0] = Object.assign({
        fill: getRandomColor()
      }, attr, attrs != null ? attrs[0] : void 0);
      this.attrs[1] = Object.assign({
        fill: getRandomColor()
      }, attr, attrs != null ? attrs[1] : void 0);
      // Initialize
      this.verts = [];
      this.tiles = [];
    }

    /**
     * Create first tile, a matching pair of half rhombs.
     * @method createFirstTile
     */
    createFirstTile(size) {
      var i, j, k;
      switch (this.opts.initTileType) {
        case "thin":
          this.verts = [[0, 0], [1, 0], [1 + r / 2, sqrt((3 - r) / 4)], [r / 2, sqrt((3 - r) / 4)]];
          for (i = j = 0; j <= 3; i = ++j) {
            this.verts[i] = mult(this.verts[i], 2 * (size - 1) / r);
          }
          return this.tiles = [new Tile(1, 0, 3, "thin", null, null, 1), new Tile(1, 2, 3, "thin", null, null, 0)];
        case "fat":
          this.verts = [[0, 0], [1, 0], [(1 + r) / 2, sqrt((r + 2) / 4)], [(r - 1) / 2, sqrt((r + 2) / 4)]];
          for (i = k = 0; k <= 3; i = ++k) {
            this.verts[i] = mult(this.verts[i], 2 * size / (1 + r));
          }
          return this.tiles = [new Tile(0, 1, 2, "fat", null, null, 1), new Tile(0, 3, 2, "fat", null, null, 0)];
      }
    }

    /**
     * Inflate (aka subdivide, decompose) tiles.
     * @method inflate
     * @param times {Number} Number of times to inflate.
     */
    inflate(times) {
      var i, j, ref, results, tile;
      results = [];
      for (j = 1, ref = times; j <= ref; j += 1) {
        results.push((function() {
          var k, len, ref1, results1;
          ref1 = this.tiles;
          results1 = [];
          for (i = k = 0, len = ref1.length; k < len; i = ++k) {
            tile = ref1[i];
            results1.push(tile.inflate(this.verts, this.tiles, i));
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    /**
     * Take a tile, match with its pair, and nullify the pair. Note that once
     * you call it, this.tiles will no longer be a complete set (will have
     * null entries in the array). Call it just before you draw polys.
     * @method reduce
     * @param tile {Tile} One of the tiles in this.tiles.
     * @return {String} Space-delimited string of vertices.
     */
    reduce(tile) {
      var pair, str;
      // Get matching pair
      pair = this.tiles[tile.pair.tile];
      // Calculate polygon vertices
      str = this.verts[tile.v0] + ' ' + this.verts[tile.v1] + ' ';
      if (pair != null) {
        str += this.verts[pair.v2] + ' ' + this.verts[pair.v1];
      } else {
        if (this.opts.rim === "clip") {
          str += this.verts[tile.v2];
        } else if (this.opts.rim === "subtractive") {
          str = null;
        } else if (this.opts.rim === "additive") {
          // Vmid = v0 + (v2 - v0)/2
          // Vnew = v1 + 2(Vmid - v1)
          str += this.verts[tile.v2] + ' ' + sum(this.verts[tile.v1], mult(diff(sum(this.verts[tile.v0], mult(diff(this.verts[tile.v2], this.verts[tile.v0]), 1 / 2)), this.verts[tile.v1]), 2));
        }
      }
      // Destroy the pair
      this.tiles[tile.pair] = null;
      // Return space-delimited string of vertices
      return str;
    }

    /**
     * Draw a Penrose tiling.
     * @method drawTiles
     * @private
     * @param draw {SVG.Container} SVG.Container instance.
     */
    drawTiles(draw) {
      var j, k, len, ref, set, tile;
      // Create set of sets
      set = draw.set();
      for (var j = 0; j <= 1; j++) {
        set.add(draw.set());
      }
      ref = this.tiles;
      // Draw tiles as polygons
      for (k = 0, len = ref.length; k < len; k++) {
        tile = ref[k];
        set.get(tile.type).add(draw.polygon(this.reduce(tile)).attr(this.attrs[tile.type]));
      }
      // Return set
      return set;
    }

  };

  PenroseKiteAndDart = class PenroseKiteAndDart {};

  // ================================
  // Private Methods

  // ================================
  // Exports
  /**
   * Creates Penrose tiling.
   * @method Moyo.penrose
   * @param [width=1000] {Number} Size of initial tile in x axis.
   * @param [opts] {Object} Options specific to Penrose tiling.
   * @param [opts.type="rhombus"] {String} Which type of Penrose tiling to generate. Available options are "rhombus", "kite and dart", and "original"
   * @param [opts.inflation=7] {Number} Number of times to inflate (aka. subdivide, decompose).
   * @param [opts.initTileType] {String} The starting tile to which subsequent inflations are applied.
   * @param [opts.rim="clip"] {String} What to do with tiling rim after the final inflation. Available options are: clip (clips off tiles), additive (protrudes rim), subtractive (removes clipping tiles)
   * @param [...attrs] {Array} Attributes for each tile types (2 types for rhombus and knd, 3 for original).
   * @return {SVG.Set} Set of sets containing tiles of the same type.
   */
  export default function(svg) {
    const SVG = svg;
    return svg.extend(SVG.Container, {
      penrose: function(width, opts, ...attrs) {
        var options, pr;
        // Overwrite default options
        options = Object.assign({
          type: "rhombus",
          inflation: new SVG.Number(7),
          rim: "clip"
        }, opts);
        options.size = new SVG.Number(width != null ? width : 100);
        options.inflation = new SVG.Number(options.inflation);
        // Sanity check
        if (options.size.unit !== '') {
          throw new Error("width must be a unitless number.");
        }
        if (!["rhombus", "rhombs", "kite and dart", "kites and darts", "knd", "original"].includes(options.type)) {
          throw new Error('"' + options.type + '"' + "is an invalid type.");
        }
        if (options.inflation.unit !== '') {
          throw new Error("inflation must be a unitless number.");
        }
        // Instantiate
        switch (options.type) {
          case "rhombus":
            pr = new PenroseRhombus(options, ...attrs);
        }
        // Generate tiles
        pr.createFirstTile(options.size.valueOf());
        pr.inflate(options.inflation.valueOf());
        // Alas, draw it
        return pr.drawTiles(this);
      }
    });
  };
